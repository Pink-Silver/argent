// --------------------------------------------------------------------------
//
// ARGENT: Base Weapon Definitions
//
// --------------------------------------------------------------------------

/*
 * Base weapon class. Contains common functions and properties for all of
 * ARGENT's weapons, naturally. Non-moddable weapons (e.g. pistol, SSG, BFG)
 * inherit directly from this class.
 */
class ArgWeapon : DoomWeapon
{
	Default
	{
		Inventory.PickupSound "items/weapon";
		Weapon.UpSound "weapons/swap";
		Weapon.BobStyle "InverseSmooth";
		Weapon.BobSpeed  2.00;
		Weapon.BobRangeX 0.75;
		Weapon.BobRangeY 0.50;
		Weapon.SelectionOrder 9999999;
		Scale 0.75;
	
		+WEAPON.NOALERT
	}
	States
	{
	Spawn:
		TNT1 A 1;
		Stop;
	Ready:
		TNT1 A 1 A_WeaponReady;
		Loop;
	Select:
	SelectLoop:
		"####" "#" 1 Arg_A_Raise();
		Loop;
	Deselect:
	DeselectLoop:
		"####" "#" 1 Arg_A_Lower();
		Loop;
	Fire:
		TNT1 A 1;
		Goto Ready;
	}
	
	/*
	 * Double-speed A_Raise/A_Lower, for convenience.
	 */
	action void Arg_A_Lower() {
		A_Lower();
		A_Lower();
	}
	action void Arg_A_Raise() {
		A_Raise();
		A_Raise();
	}
	
	/*
	 * Synth-fire convenience functions. Comes in both
	 * check and jump variants. Note that the 'checks' need to be labeled
	 * with "action" even though they kinda aren't; funky compat stuff.
	 */
	action bool Arg_SynthFire() {
		return GetPlayerInput(INPUT_BUTTONS) & BT_ATTACK;
	}
	action bool Arg_SynthAltFire() {
		return GetPlayerInput(INPUT_BUTTONS) & BT_ALTATTACK;
	}
	action state Arg_A_SynthFire(statelabel label) {
		return Arg_SynthFire() ? ResolveState(label) : ResolveState(null);
	}
	action state Arg_A_SynthAltFire(statelabel label) {
		return Arg_SynthAltFire() ? ResolveState(label) : ResolveState(null);
	}
	
	/*
	 * Weapon Offset function alias. This does two things mainly:
	 * - adjusts 'y' by 32 so that (0,0) is actually the origin, and
	 * - adds a convenient parameter for random jitter, as that's common.
	 */
	action void Arg_A_WeaponOffset(double x, double y, double j = 0, double k = 0) {
		k = (k == 0) ? j : k; // means you can't do x-only jitter, but meh
		A_WeaponOffset(x + frandom(-j, j), 32.0 + y + frandom(-k, k));
	}
}

/*
 * Base class for moddable weapons, containing all the cool common code
 * for swapping and equipping mods (as well as handling various facets
 * of mod fires like the usual "altfire to charge, fire-to-fire" system).
 * Bit complex, but most of the guts are nicely laid out here now.
 *
 * [XA] Well, they will be once I get the ACS bits converted to zscript :P.
 */
class ArgModWeapon : ArgWeapon
{
	Default
	{
		+WEAPON.NOALERT
	}
	States
	{
	
	/* Ready Mod-Jump */
	
	Ready:
		"####" "#" 0 {
			A_ClearReFire();
			return Arg_A_JumpMod("Mod1Ready", "Mod2Ready", "Mod0Ready");
		}
	Mod0Ready:
	Mod1Ready:
	Mod2Ready:
	ReadyLoop:
		"####" "#" 1 A_WeaponReady(WRF_ALLOWRELOAD);
		Loop;
		
	/* Select Mod-Jump */
	
	Select:
		"####" "#" 0 Arg_A_JumpMod("Mod1Select", "Mod2Select", "Mod0Select");
	Mod0Select:
	Mod1Select:
	Mod2Select:
		Goto SelectLoop;
		
	/* Fire Mod-Jump -- need to make sure we're not holding down altfire. */
	
	Fire:
		"####" "#" 0 {
			if(Arg_A_InstallMod(1)) {
				return ResolveState("ModSwapDown");
			} else if(!Arg_SynthAltFire()) {
				return ResolveState("Mod0Fire");
			} else {
				return ResolveState("DontFire");
			}
		}
		Goto DontFire;
	Mod0Fire:
		"####" "#" 1;
		Goto Ready;
		
	/* Deselect doesn't need a mod jump since it's just "####" anyway. */
	
	Deselect:
		"####" "#" 0 {
			A_ZoomFactor(1.0);
			A_SetCrosshair(0);
		}
		Goto DeselectLoop;
		
	/* Mod Swapping. Uses the Reload bind for convenience. */
	
	Reload:
		// call the swap function and start the animation if successful
		"####" "#" 0 Arg_A_SwapMod();
	ModSwapDown:
		// lower the weapon and jump to the raise animation
		"####" "########" 1 A_WeaponOffset(0.0, 12.0, WOF_KEEPX | WOF_ADD);
		"####" "#" 0 {
			ACS_NamedExecuteAlways("ClearModCooldown");
			return Arg_A_JumpMod("Mod1Raise", "Mod2Raise");
		}
	Mod1Raise:
	Mod2Raise:
	ModSwapUp:
		// raise the weapon & start the swap animation
		"####" "########" 1 A_WeaponOffset(0.0,-12.0, WOF_KEEPX | WOF_ADD);
		"####" "#" 0 Arg_A_JumpMod("Mod1Swap", "Mod2Swap");
	Mod1Swap:
	Mod2Swap:
	DontSwap:
		"####" "#" 1 A_WeaponReady;
		Goto Ready;
		
	/* Mod Firing. Maximum Dangertime. */
	
	AltFire:
		"####" "#" 0 {
			if(Arg_A_InstallMod(2)) {
				return ResolveState("ModSwapDown");
			} else {
				return Arg_A_JumpMod("Mod1Up", "Mod2Up", "DontFire", true);
			}
		}
	AltHold:
		"####" "#" 0 Arg_A_JumpMod("Mod1Hold", "Mod2Hold");
		Goto DontFire;
	ModDown:
		"####" "#" 0 Arg_A_JumpMod("Mod1Down", "Mod2Down");
		Goto DontFire;
	Mod1Up:
	Mod2Up:
	Mod1Hold:
	Mod2Hold:
	Mod1Down:
	Mod2Down:
	DontFire:
		"####" "#" 1 A_WeaponReady(WRF_NOFIRE);
		Goto Ready;
	Cooldown:
		"####" "#" 0 {
			A_ClearReFire();
			ACS_NamedExecuteAlways("StartModCooldown");
		}
		Goto Ready;
	}
	
	/*
	 * Jump to one of two states depending on which mod is selected.
	 * If no mods are selected, no state jump occurs.
	 */
	action state Arg_A_JumpMod(statelabel mod1label, statelabel mod2label, statelabel mod0label = null, bool checkCooldown = false) {
		// [TODO] port ACS to zscript.
		
		// Check to see if we have an active cooldown. If so and the
		// checkCooldown flag is set, don't do any jumps.
		// [TODO] make the logic a bit cleaner when I don't have to short-circuit ACS :P
		bool coolDone = checkCooldown ? CallACS("CheckModCooldown") : true;
		
		// Jump to either the mod 1 or mod 2 state depending on which exists.
		if(CallACS("ModSelected", 1) && coolDone) {
			return ResolveState(mod1label);

		} else if(CallACS("ModSelected", 2) && coolDone) {
			return ResolveState(mod2label);

		} else {
			return ResolveState(mod0label);
		}
	}
	
	/*
	 * Attempt to install the specified mod. If already installed (or the
	 * shop menu isn't opened), 'false' is returned; else 'true'.
	 */
	action bool Arg_A_InstallMod(int mod) {
		// [TODO] port ACS to zscript.

		return CallACS("EquipModCheck", mod);
	}
	
	/*
	 * Swap the currently-selected mod. 'Nuff said.
	 */
	action state Arg_A_SwapMod() {
		// [TODO] port ACS to zscript.
		
		if(CallACS("SwapMod")) {
			return ResolveState("ModSwapDown");
		} else {
			return ResolveState("DontSwap");
		}
	}
}

class ArgModToken : ArgToken { Default { Inventory.MaxAmount 2; } }
