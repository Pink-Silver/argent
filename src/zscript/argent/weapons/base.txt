// --------------------------------------------------------------------------
//
// ARGENT: Base Weapon Definitions
//
// --------------------------------------------------------------------------

/*
 * Base weapon class. Contains common functions and properties for all of
 * ARGENT's weapons, naturally. Non-moddable weapons (e.g. pistol, SSG, BFG)
 * inherit directly from this class.
 */
class ArgWeapon : DoomWeapon
{
	bool altSound;
	
	Default
	{
		Inventory.PickupSound "items/weapon";
		Weapon.UpSound "weapons/swap";
		Weapon.BobStyle "InverseSmooth";
		Weapon.BobSpeed  2.00;
		Weapon.BobRangeX 0.75;
		Weapon.BobRangeY 0.50;
		Weapon.SelectionOrder 9999999;
		Scale 0.75;
	
		+WEAPON.NOALERT
	}
	States
	{
	Spawn:
		TNT1 A 1;
		Stop;
	Ready:
		TNT1 A 1 A_WeaponReady;
		Loop;
	Select:
	SelectLoop:
		"####" "#" 1 Arg_A_Raise();
		Loop;
	Deselect:
	DeselectLoop:
		"####" "#" 1 Arg_A_Lower();
		Loop;
	Fire:
		TNT1 A 1;
		Goto Ready;
	}
	
	/*
	 * Double-speed A_Raise/A_Lower, for convenience.
	 */
	action void Arg_A_Lower() {
		A_Lower();
		A_Lower();
	}
	action void Arg_A_Raise() {
		A_Raise();
		A_Raise();
	}
	
	/*
	 * A_GunFlash extension, wrapping a whole bunch of cool
	 * common stuff, like A_WeaponReady, A_PlaySound, and the like.
	 */
	enum Arg_A_GunFlashFlags {
		ARG_GF_NOALERT  = 1, // Don't call A_AlertMonsters.
		ARG_GF_ALTSOUND = 2, // Alternate firing sound between channels 5 and 6
		ARG_GF_BOB      = 4, // Continue bobbing when firing (i.e. call A_WeaponReady)
	}
	action void Arg_A_GunFlash(statelabel flashstate = null, sound flashsound = "", int flags = 0, double recoil = 0) {
		A_GunFlash(flashstate);
		
		if(!(flags & ARG_GF_NOALERT)) {
			A_AlertMonsters();
		}
		if(flashsound != "") {
			if(flags & ARG_GF_ALTSOUND) {
				A_PlaySound(flashsound, invoker.altSound ? CHAN_6 : CHAN_5);
				invoker.altSound = !invoker.altSound;
			} else {
				A_PlaySound(flashsound, CHAN_5);
			}
		}
		if(flags & ARG_GF_BOB) {
			A_WeaponReady(WRF_NOFIRE | WRF_NOFIRE);
		}
		if(recoil > 0) {
			A_Recoil(recoil);
		}
	}
	
	/*
	 * Convenient ammo-taker function. Since ARGENT weapons only use a single
	 * ammo type, just subtract a bit from AmmoType1. Easy-peasy.
	 */
	action void Arg_A_TakeAmmo(int amount = 1)
	{
		A_TakeInventory(invoker.AmmoType1, amount, TIF_NOTAKEINFINITE);
	}
	
	/*
	 * A certain function that would've been nice to have built-in for ages. ;)
	 */
	action state Arg_A_JumpIfNoAmmo(statelabel state = 'Ready', int amount = 1)
	{
		return (CountInv(invoker.AmmoType1) < amount) ? ResolveState(state) : ResolveState(null);
	}
	
	/*
	 * Synth-fire convenience functions. Comes in both
	 * check and jump variants. Note that the 'checks' need to be labeled
	 * with "action" even though they kinda aren't; funky compat stuff.
	 */
	action bool Arg_SynthFire() {
		return GetPlayerInput(INPUT_BUTTONS) & BT_ATTACK;
	}
	action bool Arg_SynthAltFire() {
		return GetPlayerInput(INPUT_BUTTONS) & BT_ALTATTACK;
	}
	action state Arg_A_SynthFire(statelabel label) {
		return Arg_SynthFire() ? ResolveState(label) : ResolveState(null);
	}
	action state Arg_A_SynthAltFire(statelabel label) {
		return Arg_SynthAltFire() ? ResolveState(label) : ResolveState(null);
	}
	
	/*
	 * Weapon Offset function alias. This does two things mainly:
	 * - adjusts 'y' by 32 so that (0,0) is actually the origin, and
	 * - adds a convenient parameter for random jitter, as that's common.
	 */
	action void Arg_A_WeaponOffset(double x, double y, double j = 0, double k = 0) {
		k = (k == 0) ? j : k; // means you can't do x-only jitter, but meh
		A_WeaponOffset(x + frandom(-j, j), 32.0 + y + frandom(-k, k), WOF_INTERPOLATE);
	}
}

/*
 * Cool Mod struct, containing info representing a weapon mod. Is cool.
 */
struct ArgMod
{
	// [TODO] make this cooler. :(
	bool enabled;
	int ammoUse;
	ArgCounter cooldown;
	ArgCounter charge;
}

/*
 * Base class for moddable weapons, containing all the cool common code
 * for swapping and equipping mods (as well as handling various facets
 * of mod fires like the usual "altfire to charge, fire-to-fire" system).
 * Bit complex, but most of the guts are nicely laid out here now.
 *
 * [XA] Well, they will be once I get the ACS bits converted to zscript :P.
 */
class ArgModWeapon : ArgWeapon
{
	ArgMod mod1;
	ArgMod mod2;

	Default
	{
		+WEAPON.NOALERT
	}
	States
	{
	
	/* Ready Mod-Jump */
	
	Ready:
		"####" "#" 0 {
			A_ClearReFire();
			return Arg_A_JumpMod("Mod1Ready", "Mod2Ready", "Mod0Ready");
		}
	Mod0Ready:
	Mod1Ready:
	Mod2Ready:
	ReadyLoop:
		"####" "#" 1 A_WeaponReady(WRF_ALLOWRELOAD);
		Loop;
		
	/* Select Mod-Jump */
	
	Select:
		"####" "#" 0 Arg_A_JumpMod("Mod1Select", "Mod2Select", "Mod0Select");
	Mod0Select:
	Mod1Select:
	Mod2Select:
		Goto SelectLoop;
		
	/* Fire Mod-Jump -- need to make sure we're not holding down altfire. */
	
	Fire:
		"####" "#" 0 {
			if(Arg_A_InstallMod(1)) {
				return ResolveState("ModSwapDown");
			} else if(!Arg_SynthAltFire()) {
				return ResolveState("Mod0Fire");
			} else {
				return ResolveState("DontFire");
			}
		}
		Goto DontFire;
	Mod0Fire:
		"####" "#" 1;
		Goto Ready;
		
	/* Deselect doesn't need a mod jump since it's just "####" anyway. */
	
	Deselect:
		"####" "#" 0 {
			A_ZoomFactor(1.0);
			A_SetCrosshair(0);
		}
		Goto DeselectLoop;
		
	/* Mod Swapping. Uses the Reload bind for convenience. */
	
	Reload:
		// call the swap function and start the animation if successful
		"####" "#" 0 Arg_A_SwapMod();
	ModSwapDown:
		// lower the weapon and jump to the raise animation
		"####" "########" 1 A_WeaponOffset(0.0, 12.0, WOF_KEEPX | WOF_ADD);
		"####" "#" 0 {
			Arg_A_ClearModCooldown();
			return Arg_A_JumpMod("Mod1Raise", "Mod2Raise");
		}
	Mod1Raise:
	Mod2Raise:
	ModSwapUp:
		// raise the weapon & start the swap animation
		"####" "########" 1 A_WeaponOffset(0.0,-12.0, WOF_KEEPX | WOF_ADD);
		"####" "#" 0 Arg_A_JumpMod("Mod1Swap", "Mod2Swap");
	Mod1Swap:
	Mod2Swap:
	DontSwap:
		"####" "#" 1 A_WeaponReady;
		Goto Ready;
		
	/* Mod Firing. Maximum Dangertime. */
	
	AltFire:
		"####" "#" 0 {
			if(Arg_A_InstallMod(2)) {
				return ResolveState("ModSwapDown");
			} else {
				return Arg_A_JumpMod("Mod1Up", "Mod2Up", "DontFire", true);
			}
		}
	AltHold:
		"####" "#" 0 Arg_A_JumpMod("Mod1Hold", "Mod2Hold");
		Goto DontFire;
	ModDown:
		"####" "#" 0 Arg_A_JumpMod("Mod1Down", "Mod2Down");
		Goto DontFire;
	Mod1Up:
	Mod2Up:
	Mod1Hold:
	Mod2Hold:
	Mod1Down:
	Mod2Down:
	DontFire:
		"####" "#" 1 A_WeaponReady(WRF_NOFIRE);
		Goto Ready;
	Cooldown:
		"####" "#" 0 {
			A_ClearReFire();
			Arg_A_StartModCooldown();
		}
		Goto Ready;
	}
	
	/*
	 * Overridden Tick function, for handiness's sake.
	 */
	override void Tick()
	{
		Super.Tick();
		
		// Subtract 1 from mod cooldown every tick, no matter
		// what else happens. Huzzah!
		let this = ArgModWeapon(self);
		this.mod1.cooldown.dec();
		this.mod2.cooldown.dec();
	}
	
	/*
	 * Jump to one of two states depending on which mod is selected.
	 * If no mods are selected, no state jump occurs.
	 */
	action state Arg_A_JumpMod(statelabel mod1label, statelabel mod2label, statelabel mod0label = null, bool checkCooldown = false) {
		// [TODO] port ACS to zscript.
		
		// Check to see if we have an active cooldown. If so and the
		// checkCooldown flag is set, don't do any jumps.
		bool coolDone = checkCooldown ? Arg_A_CheckModCooldown() : true;
		
		// Jump to either the mod 1 or mod 2 state depending on which exists.
		if(CallACS("ModSelected", 1) && coolDone) {
			return ResolveState(mod1label);

		} else if(CallACS("ModSelected", 2) && coolDone) {
			return ResolveState(mod2label);

		} else {
			return ResolveState(mod0label);
		}
	}
	
	/*
	 * Attempt to install the specified mod. If already installed (or the
	 * shop menu isn't opened), 'false' is returned; else 'true'.
	 */
	action bool Arg_A_InstallMod(int mod) {
		// [TODO] port ACS to zscript.

		return CallACS("EquipModCheck", mod);
	}
	
	/*
	 * Swap the currently-selected mod. 'Nuff said.
	 */
	action state Arg_A_SwapMod() {
		// [TODO] port ACS to zscript.
		
		if(CallACS("SwapMod")) {
			return ResolveState("ModSwapDown");
		} else {
			return ResolveState("DontSwap");
		}
	}
	
	/*
	 * Start the cooldown cycle for the selected mod.
	 */
	action void Arg_A_StartModCooldown() {
		// [TODO] do just the selected mod, not both.
		invoker.mod1.cooldown.toMax();
		invoker.mod2.cooldown.toMax();
		
		// [TODO] remove this ACS bit once all weapons are ported over.
		CallACS("StartModCooldown");
	}
	
	/*
	 * Clear the cooldown cycle for the selected mod.
	 * Generally done on weapon swap.
	 */
	action void Arg_A_ClearModCooldown() {
		// [TODO] do just the selected mod, not both.
		invoker.mod1.cooldown.toMin();
		invoker.mod2.cooldown.toMin();
		
		// [TODO] remove this ACS bit once all weapons are ported over.
		CallACS("ClearModCooldown");
	}
	
	/*
	 * Check to see if the current weapon is still
	 * cooling down, for state jump purposes.
	 */
	action bool Arg_A_CheckModCooldown() {
		// [TODO] do just the selected mod, not both.
		// [TODO] remove this ACS bit once all weapons are ported over.
		return CallACS("CheckModCooldown")
		    && invoker.mod1.cooldown.get() == 0
		    && invoker.mod2.cooldown.get() == 0
		;
	}
}

class ArgModToken : ArgToken { Default { Inventory.MaxAmount 2; } }
